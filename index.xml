<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Engineering Notes</title>
    <link>/</link>
    <description>Recent content on Engineering Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Feb 2021 23:52:20 +0200</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 300 Longest Increasing Subsequence (Complete Search with DP) - Cpp</title>
      <link>/posts/problem-solving/leetcode-300-longest-increasing-subsequence/</link>
      <pubDate>Wed, 17 Feb 2021 23:52:20 +0200</pubDate>
      
      <guid>/posts/problem-solving/leetcode-300-longest-increasing-subsequence/</guid>
      <description>Today I&amp;rsquo;m going to resolve, explain and share my c++ solution for
 Longest Increasing Subsequence on Leetcode   It&amp;rsquo;s the most popular problem in the interviews for complete search so I resolved using recursive backtracking.
For video explaining 
Or jump to directly to the code  class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; memo; public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int length = nums.size(); memo.clear(); memo.resize(length+4, vector&amp;lt;int&amp;gt;(length+4, -1)); nums.push_back((int)-10e5); //-10000  int res = dfs(0, length, nums); nums.</description>
    </item>
    
    <item>
      <title>Cohesion In Object Oriented Design</title>
      <link>/posts/cohesion/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:06 +0200</pubDate>
      
      <guid>/posts/cohesion/</guid>
      <description>Our main topic for this series is how to write good software with this quote
 Good software is highly cohesive and loosely coupled (Separation Of Concern).
 What is the benefit from writing a good software? Writing maintainable, testable and readable code helps increase productivity for us as developers. Having highly maintainable code makes it easier to design new features and write code. Modular, component-based, and layered code increase productivity and reduce risk and cost when making changes.</description>
    </item>
    
  </channel>
</rss>